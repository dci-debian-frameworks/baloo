From a6631dc63d582e9bd1c5bea9ed1779ade6f61ed9 Mon Sep 17 00:00:00 2001
From: Vishesh Handa <me@vhanda.in>
Date: Tue, 1 Apr 2014 15:56:16 +0200
Subject: [PATCH 29/48] FileIndexingJobTest: Test timeouts

The FileIndexingJob has an internal timer to make sure the indexer never
gets stuck on any file. If so it marks that file has invalid. This test
checks for that behaviour.
---
 src/file/autotest/fileindexingjob/extractor.cpp      | 14 +++++++++++---
 .../autotest/fileindexingjob/fileindexingjobtest.cpp | 20 ++++++++++++++++++++
 .../autotest/fileindexingjob/fileindexingjobtest.h   |  1 +
 src/file/fileindexingjob.cpp                         | 11 +++++++++--
 src/file/fileindexingjob.h                           | 10 ++++++++++
 5 files changed, 51 insertions(+), 5 deletions(-)

diff --git a/src/file/autotest/fileindexingjob/extractor.cpp b/src/file/autotest/fileindexingjob/extractor.cpp
index 28a27e9..a6d14d7 100644
--- a/src/file/autotest/fileindexingjob/extractor.cpp
+++ b/src/file/autotest/fileindexingjob/extractor.cpp
@@ -31,6 +31,7 @@
 
 #include <signal.h>
 #include <iostream>
+#include <unistd.h>
 
 int main(int argc, char* argv[])
 {
@@ -55,12 +56,14 @@ int main(int argc, char* argv[])
 
     KComponentData data(aboutData, KComponentData::RegisterAsMainComponent);
 
-    QByteArray arr = qgetenv("BALOO_EXTRACTOR_FAIL_FILE");
-    if (arr.isEmpty()) {
+    QByteArray failArr = qgetenv("BALOO_EXTRACTOR_FAIL_FILE");
+    QByteArray timeoutArr = qgetenv("BALOO_EXTRACTOR_TIMEOUT_FILE");
+    if (failArr.isEmpty() && timeoutArr.isEmpty()) {
         return 0;
     }
 
-    QStringList failFiles = QString::fromUtf8(arr).split(",", QString::SkipEmptyParts);
+    QStringList failFiles = QString::fromUtf8(failArr).split(",", QString::SkipEmptyParts);
+    QStringList timeoutFiles = QString::fromUtf8(timeoutArr).split(",", QString::SkipEmptyParts);
 
     for (int i = 0; i < args->count(); i++) {
         QString fid = args->arg(i);
@@ -69,6 +72,11 @@ int main(int argc, char* argv[])
             raise(SIGKILL);
             return -1;
         }
+
+        if (timeoutFiles.contains(fid)) {
+            // 100 msecs
+            usleep(100 * 1000);
+        }
     }
 
     return 0;
diff --git a/src/file/autotest/fileindexingjob/fileindexingjobtest.cpp b/src/file/autotest/fileindexingjob/fileindexingjobtest.cpp
index ecb1b42..8a0ca84 100644
--- a/src/file/autotest/fileindexingjob/fileindexingjobtest.cpp
+++ b/src/file/autotest/fileindexingjob/fileindexingjobtest.cpp
@@ -91,4 +91,24 @@ void FileIndexingJobTest::testNormalExecution()
     QCOMPARE(spy2.count(), 1);
 }
 
+void FileIndexingJobTest::testTimeout()
+{
+    QVector<uint> files;
+    for (int i = 0; i<40; i++) {
+        files << i;
+    }
+
+    putenv("BALOO_EXTRACTOR_TIMEOUT_FILE=5");
+    FileIndexingJob* job = new FileIndexingJob(files);
+    job->setTimeoutInterval(100);
+
+    QSignalSpy spy(job, SIGNAL(indexingFailed(uint)));
+    QVERIFY(job->exec());
+
+    QCOMPARE(spy.count(), 1);
+    QCOMPARE(spy.at(0).size(), 1);
+    QCOMPARE(spy.at(0).first().toUInt(), (uint)5);
+}
+
+
 QTEST_MAIN(FileIndexingJobTest);
diff --git a/src/file/autotest/fileindexingjob/fileindexingjobtest.h b/src/file/autotest/fileindexingjob/fileindexingjobtest.h
index 3d84c7a..72945fb 100644
--- a/src/file/autotest/fileindexingjob/fileindexingjobtest.h
+++ b/src/file/autotest/fileindexingjob/fileindexingjobtest.h
@@ -35,6 +35,7 @@ private Q_SLOTS:
     void testNormalExecution();
     void testFileFail();
     void testMultiFileFail();
+    void testTimeout();
 };
 }
 
diff --git a/src/file/fileindexingjob.cpp b/src/file/fileindexingjob.cpp
index d00b840..18f8121 100644
--- a/src/file/fileindexingjob.cpp
+++ b/src/file/fileindexingjob.cpp
@@ -45,6 +45,8 @@ FileIndexingJob::FileIndexingJob(const QVector<uint>& files, QObject* parent)
     m_processTimer->setSingleShot(true);
     connect(m_processTimer, SIGNAL(timeout()),
             this, SLOT(slotProcessTimerTimeout()));
+
+    m_processTimeout = 5 * 60 * 1000;
 }
 
 void FileIndexingJob::start()
@@ -87,8 +89,7 @@ void FileIndexingJob::start(const QVector<uint>& files)
     m_process->setProcessChannelMode(QProcess::SeparateChannels);
     m_process->start(exe, args);
 
-    // start the timer which will kill the process if it does not terminate after 5 minutes
-    m_processTimer->start(5 * 60 * 1000);
+    m_processTimer->start(m_processTimeout);
 }
 
 void FileIndexingJob::slotIndexedFile(int, QProcess::ExitStatus exitStatus)
@@ -148,5 +149,11 @@ void FileIndexingJob::setCustomDbPath(const QString& path)
     m_customDbPath = path;
 }
 
+void FileIndexingJob::setTimeoutInterval(int msec)
+{
+    m_processTimeout = msec;
+}
+
+
 
 #include "fileindexingjob.moc"
diff --git a/src/file/fileindexingjob.h b/src/file/fileindexingjob.h
index 1c2c321..d09aeb6 100644
--- a/src/file/fileindexingjob.h
+++ b/src/file/fileindexingjob.h
@@ -47,6 +47,15 @@ public:
      */
     void setCustomDbPath(const QString& path);
 
+    /**
+     * Set the maximum number of msecs that each file should take in order
+     * to get indexed. If a file takes longer, then it will be marked
+     * as failing and the indexingFailed signal will be called
+     *
+     * By deafult this is 5 minutes
+     */
+    void setTimeoutInterval(int msec);
+
     virtual void start();
 
 Q_SIGNALS:
@@ -67,6 +76,7 @@ private:
 
     QProcess* m_process;
     QTimer* m_processTimer;
+    int m_processTimeout;
 
     QString m_customDbPath;
 };
-- 
1.9.1

